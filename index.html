<!DOCTYPE html>
<html lang="pt-br">
<head>
  <meta charset="UTF-8">
  <title>Painel de Diagn√≥stico Ambiente WebRTC</title>
  <style>
    body { 
      font-family: Arial, sans-serif; 
      margin: 20px; 
      background-color: #f5f5f5; 
    }
    h1 { 
      color: #333; 
    }
    #output { 
      margin-top: 20px; 
      background-color: #fff; 
      padding: 15px; 
      border: 1px solid #ddd; 
      border-radius: 4px;
      max-width: 600px;
    }
    div.ok { 
      color: green;
      margin-bottom: 5px;
    }
    div.warn { 
      color: orange;
      margin-bottom: 5px;
    }
    div.error { 
      color: red;
      margin-bottom: 5px;
    }
    button {
      padding: 10px 20px;
      font-size: 14px;
      margin-right: 10px;
      cursor: pointer;
    }
  </style>
</head>
<body>
  <h1>Painel de Diagn√≥stico Ambiente WebRTC</h1>
  <button onclick="diagnostico()">Reiniciar Diagn√≥stico</button>
  <button onclick="exportarCSV()">Exportar CSV</button>
  <div id="output"></div>

  <script>
    let resultados = [];

    /**
     * Registra uma mensagem no painel e armazena o registro
     * @param {string} msg - Mensagem a ser exibida
     * @param {string} [status='ok'] - Status da mensagem (ok, warn, error)
     */
    function log(msg, status = 'ok') {
      const div = document.createElement('div');
      div.innerHTML = msg;
      div.className = status;
      document.getElementById('output').appendChild(div);
      resultados.push({ msg, status });
    }

    /**
     * Executa os testes de diagn√≥stico do ambiente WebRTC
     */
    async function diagnostico() {
      // Limpa painel e resultados anteriores
      document.getElementById('output').innerHTML = '';
      resultados = [];
      
      log('üîç Iniciando diagn√≥stico de ambiente WebRTC...');

      // Teste de mem√≥ria, se suportado
      if (performance && performance.memory) {
        const used = (performance.memory.usedJSHeapSize / 1024 / 1024).toFixed(2);
        const total = (performance.memory.totalJSHeapSize / 1024 / 1024).toFixed(2);
        log(`üìã Mem√≥ria usada: <strong>${used} MB</strong>`, 'ok');
        log(`üì¶ Total alocada: <strong>${total} MB</strong>`, 'ok');
      } else {
        log('‚ö†Ô∏è Navegador n√£o suporta diagn√≥stico de heap memory.', 'warn');
      }

      // Verifica se a aba est√° ativa
      log(`ü™ü Aba ativa: <strong>${document.hasFocus() ? 'Sim' : 'N√£o'}</strong>`, document.hasFocus() ? 'ok' : 'warn');

      // Teste do WebSocket
      try {
        const ws = new WebSocket("wss://echo.websocket.events");
        ws.onopen = () => log('‚úÖ WebSocket conectado (rede ok)', 'ok');
        ws.onerror = () => log('‚ùå Falha ao conectar WebSocket', 'error');
      } catch (e) {
        log('‚ùå Erro ao tentar WebSocket: ' + e.message, 'error');
      }

      // Testa dispositivos de m√≠dia (microfones e alto-falantes)
      try {
        const devices = await navigator.mediaDevices.enumerateDevices();
        const mics = devices.filter(d => d.kind === 'audioinput');
        const spks = devices.filter(d => d.kind === 'audiooutput');
        log(`üé§ Microfones detectados: <strong>${mics.length}</strong>`, mics.length ? 'ok' : 'warn');
        log(`üîà Alto-falantes detectados: <strong>${spks.length}</strong>`, spks.length ? 'ok' : 'warn');
      } catch (e) {
        log('‚ùå Erro ao acessar dispositivos de m√≠dia: ' + e.message, 'error');
      }

      // Verifica permiss√£o do microfone
      try {
        const micPermission = await navigator.permissions.query({ name: 'microphone' });
        log(`üîê Permiss√£o do microfone: <strong>${micPermission.state}</strong>`, micPermission.state === 'granted' ? 'ok' : 'warn');
      } catch (e) {
        log('‚ö†Ô∏è N√£o foi poss√≠vel verificar permiss√£o de microfone.', 'warn');
      }
    }

    /**
     * Exporta os resultados do diagn√≥stico para um arquivo CSV
     */
    function exportarCSV() {
      if (resultados.length === 0) {
        alert("N√£o h√° resultados para exportar!");
        return;
      }
      let csvContent = "data:text/csv;charset=utf-8,Mensagem,Status\n";
      resultados.forEach(resultado => {
        // Remove tags HTML da mensagem antes da exporta√ß√£o
        const textoLimpo = resultado.msg.replace(/<[^>]+>/g, '');
        csvContent += `"${textoLimpo}","${resultado.status}"\n`;
      });
      const encodedUri = encodeURI(csvContent);
      const link = document.createElement("a");
      link.setAttribute("href", encodedUri);
      link.setAttribute("download", "diagnostico_resultados.csv");
      document.body.appendChild(link);
      link.click();
      document.body.removeChild(link);
    }

    // Executa o diagn√≥stico ao carregar a p√°gina
    diagnostico();
  </script>
</body>
</html>